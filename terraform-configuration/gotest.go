package test

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/eks"
	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/assert"
)

func TestEKS(t *testing.T) {
	// Path to the Terraform code that deploys the EKS cluster
	terraformDir := "../terraform/"

	// Generate a random suffix to make the cluster name unique
	uniqueID := random.UniqueId()

	// Create a TerraformOptions struct containing the options for Terraform command
	terraformOptions := &terraform.Options{
		TerraformDir: terraformDir,
		Vars: map[string]interface{}{
			"cluster_name": fmt.Sprintf("education-eks-%s", uniqueID),
		},
	}

	// Clean up resources at the end of the test
	defer terraform.Destroy(t, terraformOptions)

	// Deploy the EKS cluster
	terraform.InitAndApply(t, terraformOptions)

	// Get the Kubernetes config file generated by the Terraform code
	kubeconfigPath := filepath.Join(terraformDir, "kubeconfig")

	// Read the contents of the Kubernetes config file
	kubeconfigContents, err := os.ReadFile(kubeconfigPath)
	if err != nil {
		t.Fatal(err)
	}

	// Create an AWS session
	sess := session.Must(session.NewSession())

	// Create an EKS client with the AWS session
	eksClient := eks.New(sess)

	// Get the name of the EKS cluster
	clusterName := terraform.Output(t, terraformOptions, "cluster_name")

	// Get the status of the EKS cluster
	input := &eks.DescribeClusterInput{
		Name: aws.String(clusterName),
	}
	result, err := eksClient.DescribeCluster(input)
	if err != nil {
		t.Fatal(err)
	}

	// Verify that the EKS cluster is active
	assert.Equal(t, aws.StringValue(result.Cluster.Status), eks.ClusterStatusActive)
}
